\RequirePackage{fix-cm}
\documentclass[titlepage]{article}

\usepackage[utf8]{inputenc}
\usepackage{fullpage}    % Use the whole page
\usepackage{fancyhdr}    % Nice headers/footers
\usepackage{graphicx}    % Importing graphics
\usepackage{hyperref}    % Hyperlink references and URLs
\usepackage[figure,table]{hypcap} % Hyperlink points to the top of figures
\usepackage[usenames,dvipsnames]{xcolor}	% Logo
\usepackage{tikz,ifthen}			% Logo
\usepackage{pgf}				% Logo
\usepackage{scalefnt}				% Logo
\usepgfmodule{shapes}				% Logo
\usepgfmodule{plot}				% Logo
\usetikzlibrary{shapes,arrows,shadows,fit}
\usepackage{pgf-umlsd}
\usepackage{multirow}
\usepackage{mdwlist}
\usepackage{colortbl}
\usepackage{calc}
\usepackage{float}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{appendix}
\usepackage{listings}   %for displaying code
\usepackage{rotating}	% for sideways column headings in table


\renewenvironment{itemize*}
    {\begin{itemize}
        \setlength{\itemsep}{0pt}%
        \setlength{\parskip}{0pt}%
        \setlength{\partopsep}{0pt}%
        \setlength{\topsep}{0pt}}%
    {\end{itemize}}

\newcommand{\testcase}[3]{
    \begin{center}
    \begin{tabular}{| l | p{0.7\textwidth}|}
        \hline
        \rowcolor[gray]{0.8}\textbf{Pre-Condition:} & #1 \\ \hline
        \textbf{Action:} & #2 \\ \hline
        \rowcolor[gray]{0.8}\textbf{Post-Condition:} & #3 \\ \hline
    \end{tabular}
    \end{center}
}

% Just so we don't have to specify this twice
\newcommand\mytitle{Integration Test Plan}
\newcommand\mydate{\today}
\newcommand\myversion{1}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    pdftitle={AHOY \mytitle V\myversion},
    pdfauthor={Dustin Ingram, Aaron Rosenfeld, Maria Kolakowska, Frank Clark}
}

% To make referencing sections more biggerer and clickyer 
\newcommand{\rrref}[2]{\hyperref[#2]{#1}}
\newcommand{\sref}[1]{\hyperref[#1]{Section~\ref*{#1}}}
\newcommand{\fref}[1]{\hyperref[#1]{Figure~\ref*{#1}}}
\newcommand{\aref}[1]{\hyperref[#1]{Appendix~\ref*{#1}}}

% So we can number subsubsections too
\setcounter{secnumdepth}{5}

% For headers and footers
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\pagestyle{fancy}
	
% Page style for the title page
\fancypagestyle{plain}{
    \fancyhf{}
    \renewcommand{\headrulewidth}{0pt}
    \renewcommand{\footrulewidth}{0pt}
}

% Page style for every other page
\fancyhf{} % clear all header and footer fields
\fancyhead[L]{AHOY}
\fancyhead[C]{\mytitle}
\fancyhead[R]{\mydate}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\title{\textbf{\mytitle}}
\author{
	Frank Clark \\\url{francis.j.clark@drexel.edu}
    \and Dustin Ingram \\\url{dustin.s.ingram@drexel.edu}
	\and Maria Kolakowska \\\url{maria.j.kolakowska@drexel.edu}
    \and Aaron Rosenfeld \\\url{aaron.rosenfeld@drexel.edu}
}
\date{\mydate\\Version \myversion}
\begin{document}
\pagenumbering{roman}

\begin{figure*}
   % \vspace{-2em}
    \centering
    \scalebox{0.8}{\input{../common/logo.tikz}}
    \vspace{-4em}
\end{figure*}

\maketitle

\begin{abstract}
AHOY is an event-based simulation environment used to compare the effectiveness of different combinations of software agents, network configurations, and sensor data in real-world environments.  It is comprised of a distributed simulation engine, visualizer, and programming interface through which developers create agent software and network topologies.  Communication between virtual nodes is also simulated, providing highly realistic scenarios.
\end{abstract}

\setcounter{tocdepth}{4}
\tableofcontents
\label{toc}
\pagebreak
\pagenumbering{arabic}

\section{Introduction}
\label{sec:introduction}
\subsection{Purpose}
\label{sec:purpose}
%TODO Add number of modules or parts of the system
%TODO Add short list of modules or parts of the system
This document lays out the integration test plan for AHOY. It defines the test cases for the interaction between the (NUMBER) modules of the system: (TODO). The integration test plan for this system is based on the project requirements set forth in the Software Requirements Specification document while taking into consideration the system architecture as laid out in the Software Design Specification. The information presented here is intended for the development team, as well as the advisor and external stakeholders, which are currently Dr.~William Regli, Joseph Macker of the Naval Research Laboratory, and Dr.~Michal P\v{e}chou\v{e}k of Czech Technical University. 

\subsection{Scope}
The goal of the AHOY project is to provide a system for testing multiple agents across varying scenarios and topologies, in a distributed, event-driven way. AHOY gives the user the ability to quantitatively examine the effectiveness of specific agent designs as well as a focus on additional factors relevant to the network, including network connectivity, connection fidelity, and the agent's ability to process and transmit data.

Users of AHOY are researchers looking to improve a specific agent's performance on a network through testing across varying combinations of topologies and scenarios.

\subsection{References%
  \label{references}%
}

These documents have been used as reference materials for various technologies involved with this project.
%
\begin{itemize*}
	\item SPEYES: Sensing and Patrolling Enablers Yielding Effective SASO: \url{http://ieeexplore.ieee.org/xpls/abs\_all.jsp?arnumber=1559616}
	\item Service Sniffer Requirements Document: \url{http://servicesniffer.net/documents/requirements.html}
    \item Developing an Agent Systems Reference Architecture: \url{www.cs.drexel.edu/~dn53/papers/paper\_cameraready.pdf}
\end{itemize*}

\section{Simulation Components}
\subsection{Simulation}

\subsubsection{Simulation Acknowledges Startup Daemons}

\testcase{\texttt{Simulation} and \texttt{StartupDaemon} objects are instantiated. At least one \texttt{StartupDaemon} should be created. The start() operation has been called on the \texttt{Simulation}. }{Publish an \texttt{AckStartupEvent} from each \texttt{StartupDaemon} using their \texttt{EventAPI}.}{\_on\_ack\_startup is called for every \texttt{AckStartupEvent} published.  There are id's in the \_startup\_acks list for every \texttt{StartupDaemon} publishing the event.}

\subsection{StartupDaemon}
\subsubsection{Daemon Acknowledges StartupEvent}
\testcase{Set up a network configuration with at least one daemon.  Configure at least one agent to run.  Insert a print of a confirmation message when the simulation sends out a StartupEvent to the multicast channel, and when StartupDaemon receives such a StartupEvent.}{Start the simulation.}{Both of the newly added messages should be found in the output after the simulation is started.}

\subsubsection{Daemon Publishes AckStartupEvent}
\testcase{Set up a network configuration with at least one daemon.  Add confirmation message to be printed when Simulation publishes StartupEvent, when StartupDaemon receives a StartupEvent, when StartupDaemon is about to publish an AckStartupEvent, and when the Simulation receives an AckStartupEvent.}{Start the simulation.}{The newly added confirmation messages should be found in the output after the Simulation is started.}

\subsubsection{Daemon Starts on StartSimulationEvent}
\testcase{Configure a network with at least one daemon running, and configure at least one agent to run during the simulation.  Insert a confirmation message to be printed in start method of StartupDaemon.}{Start the simulation.}{For each StartupDaemon that should run, the newly created startup confirmation message should be found in the output.}

\subsubsection{Daemon Starts all Processes at StartSimulationEvent}
\testcase{Configure at least one process to be run during the simulation.  In StartupDaemon's \_on\_sim\_start function,
add a confirmation message stating number of local\_entities found to be started.}{Start the simulation.}{For each
daemon that runs, confirm that the number of processes it starts is equal to the number it found it has to start.  The
number of processes a daemon starts can be found by counting the number of messages StartupDaemon prints when starting a
new process.  This is done in the StartupDaemons \_start\_entity\_process function.}

\subsubsection{Daemon Terminates all Processes on StopSimulationEvent}
\testcase{Configure a simulation with at least one entity running.  Insert message to print number the number of
StartupDaemon's \_running\_pids at the end of StartupDaemon's \_restart function.}{Start the simulation. Invoke StopSimulationEvent to be published to the event channel.}{Each daemon that is running should output the newly created confirmation message and show it has 0 processes running.}

\subsection{World}
\subsubsection{Entities are Added Successfully}
\testcase{Configure the simulation to have more than one entity.  Insert print statement which outputs the total number
of entities at the end of World's add\_entity function.}{Start the simulation.}{For each entity configured, a message should have printed confirming the addition of a new entity.  Each time the message prints, the number of total entities should increment by one.}

\subsubsection{World Returns Entity by UID}
\testcase{Configure a world that contains at least one entity. In the startup script, call get\_entity(id) on the world
object, replacing id with the ID assigned to an entity. Then, print out the value returned by that entity`s  get\_uid() function.}{Start the simulation.}{The uid printed by the startup script should be equal to the uid assigned to the entity when it was first created.}

\subsubsection{Networks are Added Successfully}
\testcase{Configure the world to contain at least one network.  In the add\_network function of World, insert statement
displaying the total length of self.\_networks after the network has been added. The print statement should include the
name of the network at self.\_networks[-1].}{Start the simulation.}{For each of the networks configured, a statement should be outputted stating the name of the network, and the number of total networks should increment by one as each network is added.}

\subsubsection{World Returns Networks by Name}
\testcase{Configure at least one network.  In the startup script, after the simulation is started, call
get\_network(n\_name) on the world object, replacing n\_name with the name of the network that was configured.  Print out the name of the network that this function calls.}{Start the simulation by running the startup script (and starting any necessary daemons).}{The name of the network that is printed by the startup script should be the same as the network that was configured.}

\subsection{EventAPI}
\subsubsection{Events are Published}
\testcase{An \texttt{EventAPI} has been instantiated. An \texttt{Event} has been created.}{Call the \texttt{EventAPI}'s publish operation using the created \texttt{Event} and a delay time of 0 seconds.}{The \texttt{Event} should be sent over the Event Channel.}

\subsubsection{Events can be Delayed}
\testcase{An \texttt{EventAPI} has been instantiated. An \texttt{Event} has been created.}{Call the \texttt{EventAPI}'s publish operation using the created \texttt{Event} and any time 't' greater than 0 for the second argument.}{The \texttt{Event} should be sent over the Event Channel 't' seconds later.}

\subsubsection{Raw Data is successfully passed}
\testcase{\texttt{EventAPI} has been instantiated. Raw data has been created.}{Pass the raw data to the \texttt{EventAPI}'s push\_raw operation.}{The data can be seen and picked up over the current connection.}


\subsubsection{Subscribed Events Trigger Callbacks}
\testcase{\texttt{EventAPI} has been instantiated.  An \texttt{Event} has been instantiated. A function exists that can be called by the EventAPI.}{Call the \texttt{EventAPI}'s subscribe method with the event as the first argument, the function as the second, and any arguments for the function to follow.}{When the event subscribed to occurs, the function is called with all arguments supplied. }

\subsubsection{Entity can Unsubscribe from an Event}
\testcase{An EventAPI has subscribed to an \texttt{Event} with a callback function.}{Call the \texttt{EventAPI}'s unsubscribe\_all method with the same \texttt{Event} type subscribed to.}{Publish an \texttt{Event} of the same type. The callback function should not be executed.}

\subsection{TCPForward}
\subsubsection{Data Received Successfully}
\testcase{A \texttt{TCPForward} object has been instantiated with a valid port number.}{Call the start method of the
\texttt{TCPForward} object. Send an \texttt{Event} over the socket to the same port. }{The \_listener method should be called soon
after the message is sent. The raw \texttt{Event} should be sent over the Event Channel. }

\subsubsection{Events Forwarded to Clients}
\testcase{A \texttt{TCPForward} object has been created with at least 1 client.}{Publish an \texttt{Event} over the
Event Channel.}{All clients should receive the \texttt{Event}.}

\subsection{Entity}
\subsubsection{Setting/Retrieving Sensors}
\testcase{In a startup script, configure the world to contain at least one entity. In the script, after starting up the
simulation, create a sensor and call the add\_sensor method on an entity.  On the same entity, then call
get\_sensor(s\_name), replacing s\_name with the name of the sensor that was just added to that entity.  Finally, print the name of the sensor that this method returns.}{Start the simulation through the script.}{The name the script prints out should be the same as the name of the sensor the script tried to add to the entity at the beginning of the test.}

\subsubsection{Setting/Retrieving Cross-sectional Area}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Setting/Retrieving Linear Velocity}
\testcase{In a startup script, configure the world to contain at least one entity. In the script, after starting up the
simulation, call set\_lin\_velocity(v), replacing v with a numerical value. Then, call get\_lin\_velocity() on the same entity.}{Start the simulation through the script.}{The value returned by get\_lin\_velocity() should be equal to the value passed to the set\_lin\_velocity function.}

\subsubsection{Setting/Retrieving Forward Velocity}
\testcase{In a startup script, configure the world to contain at least one entity. In the script, after starting up the simulation, call set\_forward\_velocity(v), replacing v with a numerical value. Then, call get\_forward\_velocity() on the same entity.}{Start the simulation through the script.}{The value returned by get\_forward\_velocity() should be equal to the value passed to the set\_forward\_velocity function.}

\subsubsection{Setting/Retrieving World}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Position Change}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Moving to a New Position}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Entity Pickled Properly}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Entity Deserialized Properly}
\testcase{TODO}{TODO}{TODO}

\subsection{Node}
\subsubsection{Add an Interface}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Remove an Interface}
\testcase{TDOO}{TODO}{TODO}

\subsubsection{Add an Agent}
\testcase{TDOO}{TODO}{TODO}

\subsubsection{Send a Message}
\testcase{TDOO}{TODO}{TODO}

\subsubsection{Events Passed to Proper Agents}
\testcase{TDOO}{TODO}{TODO}

\subsection{ScriptedEntity}
\subsubsection{Scripted Entity Runs}
\testcase{TDOO}{TODO}{TODO}


\section{Networking Components}
\subsection{Interface}
\subsubsection{Messages Sent}
\testcase{An \texttt{Interface} has been instantiated with a \texttt{node} that contains at least one
\texttt{Agent}.}{Call the connect method. Pass a \texttt{Message} to the send\_message method using a valid
\texttt{Agent} ID as the second argument.}{The message should appear on the Event Channel as a
\texttt{CommunicationSendEvent}.}

\subsubsection{Proper Function Called When Message Received}
\testcase{An \texttt{Interface} has been instantiated with a proper network name and a \texttt{Node} containing at least
one \texttt{Agent}. Set\_recv\_callback has been called on the \texttt{Interface} with a valid function.}{Call the connect method of the \texttt{Interface}.  Publish an \texttt{Event} over the Event
Channel that contains the same network\_name as the \texttt{Interface} and a destination \texttt{Agent} ID.  The ID
should belong to an \texttt{Agent} on the owner \texttt{Node}.}{The function callback specified in the \_recv\_callback
of the \texttt{Interface} is called.}

\subsection{CommsEngine}
\subsubsection{Node Returned by Agent UID}
\testcase{A \texttt{Simulation} has been created with at least one \texttt{Agent} running on a \texttt{Node}. }{Call the
get\_node\_from\_agent method with a valid \texttt{Agent} ID.}{The \texttt{Node} running that \texttt{Agent} with the
given UID is returned.}

%\subsubsection{Simulation Properly Set}
%\testcase{TODO}{TODO}{TODO}

\subsection{LogLossCommsEngine}
\subsubsection{Pathloss Calculated Correctly}
\testcase{A Simulation is running with at least two \texttt{Node}s and a \texttt{LogLossCommsEngine}. }{Call \_get\_rx\_power with appropriate source \texttt{Node} and destination \texttt{Node} IDs. A valid number should be passed as the third argument for the source power. }{The function should return a number equivalent to what is expected by the equation in 4.2.3.1 of the AHOY Design Document.}

\subsubsection{Determines if a Message can be Delivered}
\testcase{A Simulation is running with at least two \texttt{Node}s and a \texttt{LogLossCommsEngine}. }{Call
\_should\_deliver with appropriate source \texttt{Node} and destination \texttt{Node} IDs. A valid number should be
passed as the third argument for the source power.  The fourth argument should be a number representing the minimum
power sensitivity required to send the message. }{The function should return True if the equation in section 4.2.3.1 of
the AHOY Design Document, using the \texttt{Node} positions and the source power as input, yields a result greater than
or equal to the minimum power required. Otherwise it returns false.}

\subsubsection{Links Updated After Movement}
\testcase{A \texttt{Simulation} is running with at least two \texttt{Node}s and a \texttt{LogLossCommsEngine}.}{Send an
EntityMoveEvent.}{The LogLossCommsEngine checks all links between the \texttt{Node}s.  If any links are created or nodes
separate beyond a linkable distance, a \texttt{LinkEvent} should be published by the \texttt{LogLossCommsEngine}.}

\subsection{EthernetCommsEngine}
\subsubsection{Proper Action Taken on CommunicationSendEvent}
\testcase{A \texttt{Simulation} is running with multiple \texttt{Node}s and an \texttt{EthernetCommsEngine}.}{Publish a
CommunicationSendEvent. }{The action assigned to the \texttt{EthernetCommsEngine} take occurs.}

\section{Event Components}
\subsection{Event}
\subsubsection{Event is Serialized}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Event is Deserialized}
\testcase{TODO}{TODO}{TODO}

\subsection{LinkEvent}
\subsubsection{Determines if Nodes are Linked}
\testcase{TODO}{TODO}{TODO}

\subsection{CommunicationSendEvent}
\subsubsection{Message is Maintained}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Source Agent UID Maintained}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Interface is Known}
\testcase{TODO}{TODO}{TODO}

\subsection{CommunicationRecvEvent}
\subsubsection{Message is Maintained}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Source Agent UID Maintained}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Interface is Known}
\testcase{TODO}{TODO}{TODO}

\subsection{EntityMoveEvent}
\subsubsection{UID Info Maintained}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Latitude Maintained}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Longitude Maintained}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Above Ground Location Maintained}
\testcase{TODO}{TODO}{TODO}

\subsubsection{Velocity Maintained}
\testcase{TODO}{TODO}{TODO}

\subsection{StartupEvent}
\subsubsection{World Instance Maintained}
\testcase{TODO}{TODO}{TODO}

\subsection{AckStartupEvent}
\subsubsection{Daemon ID Maintained}
\testcase{TODO}{TODO}{TODO}

\subsection{StartSimulationEvent}
\subsubsection{Daemon to Entity Mapping Maintained}
\testcase{TODO}{TODO}{TODO}

\subsection{StopSimulationEvent}
%Not sure what a good test case would be here
\subsubsection{TODO}
\testcase{TODO}{TODO}{TODO}

\section{Agent Components}
\subsection{Agent}
\subsubsection{Behaviors Initialized}
\testcase{An \texttt{Agent} has been created in a startup script.}{Add multiple behavior tuples to the \texttt{Agent}.
Start the \texttt{Simulation}.}{The \_behaviors dict should contain a key for each \texttt{Event}, and at least one 
\texttt{Condition} and \texttt{Action} pair for each \texttt{Event}.}

\subsubsection{Action Triggered Appropriately}
\testcase{A Simulation is running with at least one \texttt{Agent} with assigned behaviors.}{Publish an \texttt{Event}
that the \texttt{Agent} uses as a key in its behavior dict.}{For each \texttt{Action} / \texttt{Behavior} pair
associated in the \texttt{Agent}'s behavior map, the \texttt{Condition} is tested.  If it returns true, the
\texttt{Action} is performed.  If it returns false, the \texttt{Action} is not performed.}

\subsubsection{Proper Behavior Removed}
\testcase{A \texttt{Simulation} is running with at least one \texttt{Agent} with assigned behaviors.}{Call the
\texttt{Agent}'s remove\_behavior method with a behavior tuple.}{If the Agent contains a behavior set containing the
same \texttt{Event}, \texttt{Action}, and \texttt{Condition} pairs, that behavior is removed from the \texttt{Agent}'s
behavior map.}

%\subsection{Condition}
%Not sure what to do here. Its completely abstract
%\subsubsection{TODO}
%\testcase{TODO}{TODO}{TODO}

%\subsection{Action}
%\subsubsection{Action Performed When Called}
%\testcase{An \texttt{Action} has been created.}{Call the \texttt{Action}'s perform method.}{}

\subsection{MoveAction}
\subsubsection{Proper Entity is Moved}
\testcase{A \texttt{MoveAction} has been instantiated.}{Call the perform method of the \texttt{MoveAction}.}{The
\texttt{Entity} in the \_entity attribute changes its position.}


\section{Sensor Components}
\subsection{Sensor}
\subsubsection{Event Data Passed to Callbacks}
\testcase{A \texttt{Simulation} is running with a \texttt{Sensor} running on a \texttt{Node}. The \texttt{Sensor} has
subscribed at least one callback function.}{The \_publish\_data method is called during an \texttt{Event}.}{The
\texttt{Event} is passed to all callback functions subscribed to by the \texttt{Sensor}. If \_use\_event\_channel
attribute of the \texttt{Sensor} is True, then the \texttt{EventAPI} of the \texttt{Sensor}'s owner publishes the same
\texttt{Event}.}

\subsection{RadarSensor}
\subsubsection{Objects Properly Detected}
\testcase{A \texttt{Simulation} is running with multiple \texttt{Node}s and a \texttt{RadarSensor} running on one of the
\texttt{Node}s.}{The run method of the \texttt{RadarSensor} is called.}{For each object in the \texttt{Simulation}, if
the pathloss of an object relative to the radar antenna is below the sensitivity of an antenna, the object is not
detected.  Otherwise, its distance is calculated for each entity should be the same as the result of the distance
equation in section 4.5.2.1 of AHOY's Design Document. The velocity of the entity being detected should be equivalent to
that produced by the Doppler equation, also found in section 4.5.2.1 of the Design Document.}


\section{Utility Components}
\subsection{Geo}
\subsubsection{Haversine Distance Calculated Correctly}
\testcase{}{Call Geo.haver\_distance with latitude and longitude arguments.}{A correct Haversine distance is returned.}

\subsubsection{Linear Distance Calculated Correctly}
\testcase{}{Geo.linear\_distance is called with latitude and longitude arguments}{The correct linear distance between
the points is returned.}

\subsubsection{Lat/Lon/Agl Converted to Cartesian Coords}
\testcase{}{Geo.sph\_to\_lin is called with a latitude, longitude, and above ground location in that order.}{A
correct conversion into Cartesian coordinates is returned.}

\subsubsection{Cartesian Coords Converted to Lat/Lon/Agl}
\testcase{}{Geo.lin\_to\_sph is called with Cartesian x, y, and z coordinates.}{The input coordinates are correctly
converted to latitude, longitude, and above aground location points.}

\subsubsection{Kilometers converted to radians Correctly}
\testcase{}{Geo.loc\_from\_bearing\_dist is called with appropriate latitude and longitude inputs.}{The kilometers along
the latitude and longitude lines are
correctly converted to radians and returned.}

\subsubsection{Location and Bearing Calculated Correctly}
\testcase{}{Geo.loc\_from\_bearing\_dist is called with valid longitude/latitude points along with a bearing and
distance.}{The correct location of an object after moving from the given lat/lon at the given bearing for the given
distance is returned.}





\pagebreak
\appendix
\appendixpage

\section{Definitions, Acronyms, and Abbreviations}
\label{sec:glossary}
\begin{description}
\item[Agent]
	Agents are simulated pieces of software that run on nodes in the network. They consist of different algorithms that are relevant for the user to test on different scenarios and topologies.   
\item[Distribution]
	Distribution refers to the process of distributing the simulation across a multi-platform physical cluster.  This allows the system to exceed the number of nodes per platform for a single simulation at the system's discretion.  A framework is provided to allow the user to distribute their simulation. 	
\item[Node]
	Nodes are virtual or physical machines that consist of agents and network interfaces.  If nodes are virtual, many nodes may run on one physical machine.  
\item[Scenario]
	Scenario is comprised of a scripted language indicating the location simulated nodes within the virtual world. These nodes consist of agents (see definition of `Agent') and non-agent world objects such as planes, boats, ground vehicles, etc. 
\item[Multicast]
    A method of simultaniously delivering a message to many computers.
\item[TCP]
    Transmission Control Protocol.  A reliable, connection-oriented, communication method guaranteeing in-order, error-free delivery of all messages.
\item[Terrain]
	Terrain refers to the simulated landscape.  This includes such geography as the slope of the land, the tree density, water v.s. land surfaces, etc.
\item[Topology]
	Topology describes time-dependent connections between nodes and their characteristics (e.g. radio model). It is described with a scripting language which specifies the details of network interfaces on each simulated node, including radio models and throughput characteristics.  It describes any physical or wireless links that connect these interfaces.  Further, it indicates changes in linkage over time such as a wireless interface switches, wireless LANs, or a physical link being created or severed. 
\item[UDP]
    User Datagram Protocol.  A stateless, non-connection-oriented, communication method which does not guarantee in-order, error-free delivery of messages.
\item[Visualizer]
	The Visualizer allows the simulations to be superimposed over real-world topography.  This permits the user to examine the behavior of the agents.  It also allows for overlays such as link quality, traffic rates, and other metrics deemed important to specific components.
\end{description}

\end{document}
